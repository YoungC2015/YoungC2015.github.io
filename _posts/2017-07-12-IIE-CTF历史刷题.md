---
layout: post
date:   2017-07-12 23:25:54
categories: 学习笔记
tags:   ctf reverse
---

## 壹、 2017-06 re1: rere
由赵兄先解出来，我后来花了一下时间，也解出来了。卡住的点有二：
- 一是一个实现strlen的反汇编，源码的确是使用strlen，进行了神奇的优化……思路是把输入字符串以DWORD进行操作，减去0x01010101，和0x80808080进行相与，再与自身的取反相与。得到的数不为零则说明未到字符串末尾。<br>
现在写文章的时候把原理想通了，0x80808080相与就是判断最高位是否在取反和减一时均为1，取反时要为1说明原来必须是0，减一后要影响到首位，说明只能是0；这里再考虑一个向前一字节借位的情况，如果发生借位了，就说明这一个比以小，还是0。所以这里就0字符截断了。但是停止之后，指针是在截断位置后面的。
然后后面有一个不明就里的判断较低的2个by特是否有数据（改为与0x8080），如果有，再把指针后推2 byte，把相与的结果右移16位。然后再将该结果的低8位自加，再加上起始位置加3的地方。指针与该值相减就是长度。<br>
分析：①最后一块有3个字节，指针较0x00后了3位，那么该结果低8位自加为0，相减即得长度。<br>
②最后一块2个字节，指针较0x00后了4位，，该结果自加带进位，多减了一个，相减还是长度。<br>
③最后一块1个字节，指针不后移2，较0x00后了还是3（5-2）位，相减即长度。<br>
④最后一块只有零字符，指针相较后移4，但是该结果最后是0x80，加法进位，多减一个，相减还是长度。
<br>还有遇见一个__CFADD__的函数，其实就是带进位的加法。

- 另一个是是对数组的取不敏感，还有就是指针之类的要留意，加减什么的很多就是对数组的操作。

逆出来就是一个将输入进行
这里用到了一个解多元一次方程组的方法。用的是python的numpy的库，用matrix构建好系数矩阵和结果矩阵（matrix.T就是转置)，然后numpy.linalg.solve(arg,B)解出。注意一个float取整是向下的问题，用round先四舍五入变整之后再int转化。



## 贰、 2016-09 re1： reverse1
自己自行对照一定的源码和题解接触。主要是一个C++的逆向。用ida f5插件看的，零星记录几点

首先是类的申明与初始化上，像官方库里面的构造一般调用的父类的生成方法，也就是新建的那个变量是第一个参数。然后是一些重载的操作符也是类似函数调用的方法使用的。
习惯了这样之后看f5出来的代码还是比较轻松的。

直接撸汇编的方法下次见到了再研究。这里顺手记录一个逆出来的素数生成算法：

	ehprimo=[0,]*1024
	primos = []
	for i in range(2,1024):
		ehprimo[i] = i % 2
	for j in range(3,1024,2):
		if ehprimo[j]:
			primos.append(j)
			for k in range(j*j,1024,j):
				ehprimo[k]=0

有点意思，下回分解

## 叁、 2016-10 pwn1: clever-boy
这题很简单，ida看反汇编如下：<br>
<img src="{{ site.baseurl }}/images/PEXRUCBLKF[]~W(`]S`M7ZF.png"><br>
观察布局，发现name字符串在低地址，后面两个int也是可以修改的，然后最后还会调用这个name输出，所以就想着消除中间的零字符。
一开始用的python直接把后面俩个个地址盖住，发现不行，scanf最后还是会自动添加零字符。
看了writeup（看快了，不开心）是再逐个输入的，类似这样：

`python -c "print 'A'*52; print 808464432; print 808464432;"`
808464432 = 0x30303030，这里用-1等非全0的就行了，但是我为了输出好看……