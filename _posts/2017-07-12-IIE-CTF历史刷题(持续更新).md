---
layout: post
date:   2017-07-12 23:25:54
categories: 学习笔记
tags:   ctf reverse
---

## 壹、 2017-06 re1: rere
由赵兄先解出来，我后来花了一下时间，也解出来了。卡住的点有二：
- 一是一个实现strlen的反汇编，源码的确是使用strlen，进行了神奇的优化……思路是把输入字符串以DWORD进行操作，减去0x01010101，和0x80808080进行相与，再与自身的取反相与。得到的数不为零则说明未到字符串末尾。<br>
现在写文章的时候把原理想通了，0x80808080相与就是判断最高位是否在取反和减一时均为1，取反时要为1说明原来必须是0，减一后要影响到首位，说明只能是0；这里再考虑一个向前一字节借位的情况，如果发生借位了，就说明这一个比以小，还是0。所以这里就0字符截断了。但是停止之后，指针是在截断位置后面的。
然后后面有一个不明就里的判断较低的2个by特是否有数据（改为与0x8080），如果有，再把指针后推2 byte，把相与的结果右移16位。然后再将该结果的低8位自加，再加上起始位置加3的地方。指针与该值相减就是长度。<br>
分析：①最后一块有3个字节，指针较0x00后了3位，那么该结果低8位自加为0，相减即得长度。<br>
②最后一块2个字节，指针较0x00后了4位，，该结果自加带进位，多减了一个，相减还是长度。<br>
③最后一块1个字节，指针不后移2，较0x00后了还是3（5-2）位，相减即长度。<br>
④最后一块只有零字符，指针相较后移4，但是该结果最后是0x80，加法进位，多减一个，相减还是长度。
<br>还有遇见一个__CFADD__的函数，其实就是带进位的加法。

- 另一个是是对数组的取不敏感，还有就是指针之类的要留意，加减什么的很多就是对数组的操作。

逆出来就是一个将输入进行
这里用到了一个解多元一次方程组的方法。用的是python的numpy的库，用matrix构建好系数矩阵和结果矩阵（matrix.T就是转置)，然后numpy.linalg.solve(arg,B)解出。注意一个float取整是向下的问题，用round先四舍五入变整之后再int转化。



## 贰、 2016-09 re1： reverse1
自己自行对照一定的源码和题解接触。主要是一个C++的逆向。用ida f5插件看的，零星记录几点

首先是类的申明与初始化上，像官方库里面的构造一般调用的父类的生成方法，也就是新建的那个变量是第一个参数。然后是一些重载的操作符也是类似函数调用的方法使用的。
习惯了这样之后看f5出来的代码还是比较轻松的。

直接撸汇编的方法下次见到了再研究。这里顺手记录一个逆出来的素数生成算法：

	ehprimo=[0,]*1024
	primos = []
	for i in range(2,1024):
		ehprimo[i] = i % 2
	for j in range(3,1024,2):
		if ehprimo[j]:
			primos.append(j)
			for k in range(j*j,1024,j):
				ehprimo[k]=0

有点意思，下回分解

## 叁、 2016-10 pwn1: clever-boy
这题很简单，ida看反汇编如下：<br>
<img src="{{ site.baseurl }}/images/PEXRUCBLKF[]~W(`]S`M7ZF.png"><br>
观察布局，发现name字符串在低地址，后面两个int也是可以修改的，然后最后还会调用这个name输出，所以就想着消除中间的零字符。
一开始用的python直接把后面俩个个地址盖住，发现不行，scanf最后还是会自动添加零字符。
看了writeup（看快了，不开心）是再逐个输入的，类似这样：

`python -c "print 'A'*52; print 808464432; print 808464432;"`
808464432 = 0x30303030，这里用-1等非全0的就行了，但是我为了输出好看……

## 肆、 2016-10 pwn2： 栈溢出，ROP,利用GOT表

本来以为比较复杂结果很简单，但是还是没有自己找到，关闭了栈保护，直接溢出就能用，使用scanf再读入字符串"/bin/sh"

### 记录：
使用PLT表就是方便动态解析，就不需要关系库函数被加载到什么位置了。PLT表应该不基址重定位<br>
checksec命令检查是否开启了相关保护<br>
objdump -S参数观察哪些段可写，哪些可执行<br>
gdb中info variables检查相关变量。有没有只看有debug符号的方法？debug符号？<br>
gdb中print 命令查看相关变量信息，加&是地址<br>
gdb中x /[数目][显示方式he(x),(c)har,(i)nstruct,][(b)yte,(h)2byte,(w)ord,(g)8byte] 地址 <br>
在程序运行主线程上是有字符串"SHELL=/bin/sh"这样的字符串存在的，在栈上，回溯就能找到。


### 关于GOT表：
pwnable 里面 passcode 一题就使用的GOT覆盖的技术，GOT表是可写的，然后存储的是函数起始地址，在PLT中的函数以 `jmp *0xAAAA` 的形式跳转动态解析并且函数调用。
关于如何进行解析，[参考](http://blog.csdn.net/linyt/article/details/51637832)，简述如下：

GOT表位于.got.plt段中，plt表位于.plt段中。
linux采用延迟绑定技术，由ld-linux负责，大致运行如下（以调用puts为例）：<br>
程序调用时调用的是puts@plt，即调用的是plt表中的puts函数的地址。
一开始，这个地方是下面这3句命令
```
jmp ptr[AAA];
push xx;
jmp <addr>;
```
这里，第一个指针指向的是.got.plt表中的地址AAA，第一次调用的时候就指回了后面紧邻的push指令；<br>
push的是一个函数的ID。然后后一个jmp是跳转到一个处理解析函数，最后会来到_dl_runtime_resolve函数，也就是开始了动态解析这个函数地址的过程。<br>
解析完成之后，这个got表中原先那个AAA就被替换掉了，成为了真实的puts函数的地址。不需要再动态解析了。
注意这个AAA的地址，这个GOT表是可以修改的，但是这个PLT表是不可以修改的。在pwn的应该注意不要搞混。<br>

linux下可以用`objdump -d -s`来查看所有区段的信息，但是不够友好。<br>
`readelf -r；readelf -s`也可以查看区段信息。<br>
gdb里又有`file`命令可以查看。

