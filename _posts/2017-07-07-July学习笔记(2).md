---
layout: post
date:   2017-07-09 15:14:54
categories: 学习笔记
tags:   linux shellcode pwnable
---
# 1. linux下基本shellcode的编写

刷到了pwnable.kr中的asm题，开始系统学习shellcode。问题代码专注写利用即可，抽象如下：

	char code[] = "bytecode will go here!";
	int main(int argc, char **argv)
	{
		int (*func)();
		func = (int (*)()) code;
		(int)(*func)();
	}

关闭保护的方法：<br>
echo 0 > /proc/sys/kernel/exec-shield   #turn it off<br>
echo 0 > /proc/sys/kernel/randomize_va_space #turn it off<br>

这里我打算用两个方法写shellcode.
## 1 原始的汇编方法。
汇编可以使用如下命令来生成和提取：

	$ nasm -f elf exit.asm
	$ ld -o exiter exit.o
	$ objdump -d exiter
这里有一个困扰了我的问题，就是字符串怎么传入的问题，这里方法很巧妙，就是把字符串放在末尾，前面使用call的方式，这样字符串的地址就出现在了栈上，就可以pop到想要的寄存器中去了。

## 2 使用pwntools工具，pwn.shelldrift


---
# 3. Linux沙箱: seccomp sandbox  *(pwnable中asm)*

Seccomp(secure computing)是Linux kernel （自从2.6.23版本之后）所支持的一种简洁的sandboxing机制。它能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system calls），即read(), write(), exit()和sigreturn()，否则进程便会被终止。

- seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, ...);
- seccomp_rule_add_array(scmp_filter_ctx ctx,
                                  uint32_t action, int syscall,
                                  unsigned int arg_cnt,
- seccomp_rule_add_exact(scmp_filter_ctx ctx, uint32_t action,
                                  int syscall, unsigned int arg_cnt, ...);
- seccomp_rule_add_exact_array(scmp_filter_ctx ctx,
                                        uint32_t action, int syscall,
                                        unsigned int arg_cnt,
                                        const struct scmp_arg_cmp *arg_array);

以上等方法会添加新的过滤器到seccomp过滤器中。这个方法会因为处理器架构的不同而在细节上有一些差异。新添加的filter rule需要通过[seccomp_load(3)](http://man7.org/linux/man-pages/man3/seccomp_load.3.html)来生效。[参见linux man手册](http://man7.org/linux/man-pages/man3/seccomp_rule_add.3.html)

如下面是pwnable.kr中asm的题目代码，可以作为一个范例

	#include <seccomp.h>
	scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL);
	...
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0);
	...
	seccomp_load(ctx); //enable
	seccomp_release(ctx);

表明允许open这一系统调用的进行。

注，gcc编译时应该使用 -lseccomp参数

---